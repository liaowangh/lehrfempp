<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LehrFEM++: lf::refinement::MeshHierarchy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "bm.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// This file defines a number of macros which can be used in 
// formulas of the doxygen documentation.
MathJax.Hub.Config({
  TeX: {
    Macros: {
      vec: ["\\boldsymbol{#1}", 1],
      grad: "\\vec{\\operatorname{grad}}",
      norm: ["\\left\\lVert#1\\right\\rVert", 1]
    }
  }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LehrFEM++
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">A simple Finite Element Library for teaching</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelf.html">lf</a></li><li class="navelem"><a class="el" href="namespacelf_1_1refinement.html">refinement</a></li><li class="navelem"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classlf_1_1refinement_1_1_mesh_hierarchy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lf::refinement::MeshHierarchy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A hierarchy of nested 2D hybrid meshes created by refinement.  
 <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh__hierarchy_8h_source.html">lf/refinement/mesh_hierarchy.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a148043f4794d7c4f4e71382006bd4708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a148043f4794d7c4f4e71382006bd4708">MeshHierarchy</a> (const std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt; &amp;base_mesh, std::unique_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html">mesh::MeshFactory</a> &gt; mesh_factory)</td></tr>
<tr class="memdesc:a148043f4794d7c4f4e71382006bd4708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mesh hierarchy with an existing coarsest mesh.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a148043f4794d7c4f4e71382006bd4708">More...</a><br /></td></tr>
<tr class="separator:a148043f4794d7c4f4e71382006bd4708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10de191109487dbf85b47569f0436c14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a10de191109487dbf85b47569f0436c14">MeshHierarchy</a> (const <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;)=delete</td></tr>
<tr class="separator:a10de191109487dbf85b47569f0436c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc774617bd6c1c960ffaee7026f68fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#abc774617bd6c1c960ffaee7026f68fe9">operator=</a> (const <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;)=delete</td></tr>
<tr class="separator:abc774617bd6c1c960ffaee7026f68fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac210c02aec4ae49d35e3247fdd8a7621"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac210c02aec4ae49d35e3247fdd8a7621">MeshHierarchy</a> (<a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac210c02aec4ae49d35e3247fdd8a7621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb411a057bb85d8c585d4ff09edeee7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#adb411a057bb85d8c585d4ff09edeee7f">operator=</a> (<a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:adb411a057bb85d8c585d4ff09edeee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36a331c1ae18dc09cf8eb720feae67a"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac36a331c1ae18dc09cf8eb720feae67a">NumLevels</a> () const</td></tr>
<tr class="memdesc:ac36a331c1ae18dc09cf8eb720feae67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of meshes contained in the hierarchy, 1 for a single mesh  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac36a331c1ae18dc09cf8eb720feae67a">More...</a><br /></td></tr>
<tr class="separator:ac36a331c1ae18dc09cf8eb720feae67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6af114a5d79f8cf99ed0d501dd417c1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#af6af114a5d79f8cf99ed0d501dd417c1">getMesh</a> (size_type level) const</td></tr>
<tr class="memdesc:af6af114a5d79f8cf99ed0d501dd417c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the mesh on a particular level  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#af6af114a5d79f8cf99ed0d501dd417c1">More...</a><br /></td></tr>
<tr class="separator:af6af114a5d79f8cf99ed0d501dd417c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c5d43197587173c285f2689868bd9d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a94c5d43197587173c285f2689868bd9d">getMesh</a> (size_type level)</td></tr>
<tr class="memdesc:a94c5d43197587173c285f2689868bd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the mesh on a particular level  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a94c5d43197587173c285f2689868bd9d">More...</a><br /></td></tr>
<tr class="separator:a94c5d43197587173c285f2689868bd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f47c1d0b430311541771d26dceec21"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a43f47c1d0b430311541771d26dceec21">getMeshes</a> () const</td></tr>
<tr class="memdesc:a43f47c1d0b430311541771d26dceec21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides array of shared pointers to meshes contained in the hierarchy.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a43f47c1d0b430311541771d26dceec21">More...</a><br /></td></tr>
<tr class="separator:a43f47c1d0b430311541771d26dceec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac538ac9d7b9f1128a251ab17dbd125b7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_point_child_info.html">PointChildInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac538ac9d7b9f1128a251ab17dbd125b7">PointChildInfos</a> (size_type level) const</td></tr>
<tr class="memdesc:ac538ac9d7b9f1128a251ab17dbd125b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain refinement information for all points.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ac538ac9d7b9f1128a251ab17dbd125b7">More...</a><br /></td></tr>
<tr class="separator:ac538ac9d7b9f1128a251ab17dbd125b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe86a285de7b155b4eabc7233cba4a5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html">EdgeChildInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a0fe86a285de7b155b4eabc7233cba4a5">EdgeChildInfos</a> (size_type level) const</td></tr>
<tr class="memdesc:a0fe86a285de7b155b4eabc7233cba4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain refinement information for all edges.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a0fe86a285de7b155b4eabc7233cba4a5">More...</a><br /></td></tr>
<tr class="separator:a0fe86a285de7b155b4eabc7233cba4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334d3018f4bad589a6a81e52df16e178"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html">CellChildInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a334d3018f4bad589a6a81e52df16e178">CellChildInfos</a> (size_type level) const</td></tr>
<tr class="memdesc:a334d3018f4bad589a6a81e52df16e178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain refinement information for all.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a334d3018f4bad589a6a81e52df16e178">More...</a><br /></td></tr>
<tr class="separator:a334d3018f4bad589a6a81e52df16e178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b2981a5c074c72e56c4592a5f253d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structlf_1_1refinement_1_1_parent_info.html">ParentInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a546b2981a5c074c72e56c4592a5f253d">ParentInfos</a> (size_type level, dim_t codim) const</td></tr>
<tr class="memdesc:a546b2981a5c074c72e56c4592a5f253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch information about parents.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a546b2981a5c074c72e56c4592a5f253d">More...</a><br /></td></tr>
<tr class="separator:a546b2981a5c074c72e56c4592a5f253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae631d3d4b080210e7fe28b0cb18a6a1b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; sub_idx_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ae631d3d4b080210e7fe28b0cb18a6a1b">RefinementEdges</a> (size_type level) const</td></tr>
<tr class="memdesc:ae631d3d4b080210e7fe28b0cb18a6a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access refinement edge indices.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ae631d3d4b080210e7fe28b0cb18a6a1b">More...</a><br /></td></tr>
<tr class="separator:ae631d3d4b080210e7fe28b0cb18a6a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f62ce5f838a648e584015fc712ab27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a40f62ce5f838a648e584015fc712ab27">RefineRegular</a> (<a class="el" href="namespacelf_1_1refinement.html#aad00cb5a8084400b931b01984d2cdc5d">RefPat</a> ref_pat=RefPat::rp_regular)</td></tr>
<tr class="memdesc:a40f62ce5f838a648e584015fc712ab27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform regular or barycentric uniform refinement of the finest mesh in the hierarchy.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a40f62ce5f838a648e584015fc712ab27">More...</a><br /></td></tr>
<tr class="separator:a40f62ce5f838a648e584015fc712ab27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4608cfc81660a615e4a23c1476b7a7d"><td class="memTemplParams" colspan="2">template&lt;typename Marker &gt; </td></tr>
<tr class="memitem:aa4608cfc81660a615e4a23c1476b7a7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#aa4608cfc81660a615e4a23c1476b7a7d">MarkEdges</a> (Marker &amp;&amp;marker)</td></tr>
<tr class="memdesc:aa4608cfc81660a615e4a23c1476b7a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the edges of a mesh based on a predicate.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#aa4608cfc81660a615e4a23c1476b7a7d">More...</a><br /></td></tr>
<tr class="separator:aa4608cfc81660a615e4a23c1476b7a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d5d31b5aaf0b9e077d890f3062022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a693d5d31b5aaf0b9e077d890f3062022">RefineMarked</a> ()</td></tr>
<tr class="memdesc:a693d5d31b5aaf0b9e077d890f3062022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct local refinement of the mesh splitting all marked edges.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a693d5d31b5aaf0b9e077d890f3062022">More...</a><br /></td></tr>
<tr class="separator:a693d5d31b5aaf0b9e077d890f3062022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71cfa216aa13d280d814894811b09b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ab71cfa216aa13d280d814894811b09b2">Coarsen</a> ()</td></tr>
<tr class="memdesc:ab71cfa216aa13d280d814894811b09b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Destroy</em> the mesh on the finest level unless it is the base mesh  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#ab71cfa216aa13d280d814894811b09b2">More...</a><br /></td></tr>
<tr class="separator:ab71cfa216aa13d280d814894811b09b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac0a1402387dd65921e3c1adc8752bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlf_1_1geometry_1_1_geometry.html">lf::geometry::Geometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#acac0a1402387dd65921e3c1adc8752bc">GeometryInParent</a> (size_type level, const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;e) const</td></tr>
<tr class="memdesc:acac0a1402387dd65921e3c1adc8752bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape of child entity in parent's reference coordinates  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#acac0a1402387dd65921e3c1adc8752bc">More...</a><br /></td></tr>
<tr class="separator:acac0a1402387dd65921e3c1adc8752bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ca0ccdbbb8a52174f1c4ff64cdb41"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a031ca0ccdbbb8a52174f1c4ff64cdb41">ParentEntity</a> (size_type level, const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;e) const</td></tr>
<tr class="memdesc:a031ca0ccdbbb8a52174f1c4ff64cdb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the parent of an entity contained in a mesh of a refinement hierarchy.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a031ca0ccdbbb8a52174f1c4ff64cdb41">More...</a><br /></td></tr>
<tr class="separator:a031ca0ccdbbb8a52174f1c4ff64cdb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b24ba9cfaefc163844b21c7d023c8a2"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a6b24ba9cfaefc163844b21c7d023c8a2">PrintInfo</a> (std::ostream &amp;o) const</td></tr>
<tr class="memdesc:a6b24ba9cfaefc163844b21c7d023c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output of information about the mesh hierarchy.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a6b24ba9cfaefc163844b21c7d023c8a2">More...</a><br /></td></tr>
<tr class="separator:a6b24ba9cfaefc163844b21c7d023c8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dbdcde909f8c68b9fb1ed3851c3342"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#aa3dbdcde909f8c68b9fb1ed3851c3342">~MeshHierarchy</a> ()=default</td></tr>
<tr class="separator:aa3dbdcde909f8c68b9fb1ed3851c3342"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af46f2b1255d3fcd15e30aac0ffbb98d9"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#af46f2b1255d3fcd15e30aac0ffbb98d9">output_ctrl_</a></td></tr>
<tr class="memdesc:af46f2b1255d3fcd15e30aac0ffbb98d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">diagnostics control variable  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#af46f2b1255d3fcd15e30aac0ffbb98d9">More...</a><br /></td></tr>
<tr class="separator:af46f2b1255d3fcd15e30aac0ffbb98d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f77d2d63daeeaedff7b10ecd6ef40f1"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a1f77d2d63daeeaedff7b10ecd6ef40f1">ctrl_</a></td></tr>
<tr class="memdesc:a1f77d2d63daeeaedff7b10ecd6ef40f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control variable.  <a href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a1f77d2d63daeeaedff7b10ecd6ef40f1">More...</a><br /></td></tr>
<tr class="separator:a1f77d2d63daeeaedff7b10ecd6ef40f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de0f442177771c5f118ff6a63e11c67"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a4de0f442177771c5f118ff6a63e11c67">kout_meshinfo</a> = 2</td></tr>
<tr class="separator:a4de0f442177771c5f118ff6a63e11c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A hierarchy of nested 2D hybrid meshes created by refinement. </p>
<p>This is the fundamental class for managing sequences of meshes that have been created by successive local or global refinement of an initial coarsest mesh. Objects of this class store comprehensive information about the relationship of the meshes in the sequence: parent-child relationships of mesh cells and local refinement patterns.</p>
<h4>sample usage</h4>
<div class="fragment"><div class="line">  <span class="comment">// Generate test mesh</span></div>
<div class="line">  std::shared_ptr&lt;lf::mesh::Mesh&gt; mesh_p =</div>
<div class="line">      <a class="code" href="namespacelf_1_1mesh_1_1test__utils.html#aac2db44aee673bd5c8a74e8577f0d851">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a>(0);</div>
<div class="line">  <span class="comment">// Construction of a mesh hierarchy requires a factory object</span></div>
<div class="line">  std::unique_ptr&lt;lf::mesh::hybrid2d::MeshFactory&gt; mesh_factory_ptr =</div>
<div class="line">      std::make_unique&lt;lf::mesh::hybrid2d::MeshFactory&gt;(2);</div>
<div class="line">  <span class="comment">// Initialize still flat MESH HIERARCHY containing a single mesh</span></div>
<div class="line">  <a class="code" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">lf::refinement::MeshHierarchy</a> multi_mesh(mesh_p, std::move(mesh_factory_ptr));</div>
<div class="line">  <span class="comment">// Perform a first step of regular refinement: adds a mesh</span></div>
<div class="line">  multi_mesh.RefineRegular();</div>
<div class="line">  <span class="comment">// For demonstration purposes: Mark edges whose center lies inside a square</span></div>
<div class="line">  <span class="comment">// type: std::function&lt;bool(const lf::mesh::Mesh &amp;, const lf::mesh::Entity</span></div>
<div class="line">  <span class="comment">// &amp;edge)&gt;, but &#39;auto&#39; faster.</span></div>
<div class="line">  <span class="keyword">auto</span> marker = [](<span class="keyword">const</span> <a class="code" href="classlf_1_1mesh_1_1_mesh.html">lf::mesh::Mesh</a> &amp;mesh,</div>
<div class="line">                   <span class="keyword">const</span> <a class="code" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;edge) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    Eigen::MatrixXd ref_c = (Eigen::MatrixXd(1, 1) &lt;&lt; 0.5).finished();</div>
<div class="line">    Eigen::VectorXd c(edge.Geometry()-&gt;Global(ref_c));</div>
<div class="line">    <span class="keywordflow">return</span> ((c[0] &gt; 1.0) &amp;&amp; (c[0] &lt; 2.0) &amp;&amp; (c[1] &gt; 1.0) &amp;&amp; (c[1] &lt; 2.0));</div>
<div class="line">  };</div>
<div class="line">  <span class="comment">// mark edges for which predicate returns true</span></div>
<div class="line">  multi_mesh.MarkEdges(marker);</div>
<div class="line">  <span class="comment">// Refine current finest mesh locally: adds another mesh to the hierarchy</span></div>
<div class="line">  multi_mesh.RefineMarked();</div>
<div class="line">  <span class="comment">// Finally obtain pointer to finest mesh in the hierarchy with three meshes</span></div>
<div class="line">  std::shared_ptr&lt;const mesh::Mesh&gt; fine_mesh = multi_mesh.getMesh(2);</div>
</div><!-- fragment --><p> In the context of studying convergence of finite elemment method objects of type <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html" title="A hierarchy of nested 2D hybrid meshes created by refinement.">MeshHierarchy</a> can be employed to hold sequencies of uniformly refine meshes, see <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a40f62ce5f838a648e584015fc712ab27">MeshHierarchy::RefineRegular()</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a148043f4794d7c4f4e71382006bd4708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148043f4794d7c4f4e71382006bd4708">&#9670;&nbsp;</a></span>MeshHierarchy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lf::refinement::MeshHierarchy::MeshHierarchy </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classlf_1_1mesh_1_1_mesh_factory.html">mesh::MeshFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>mesh_factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize mesh hierarchy with an existing coarsest mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_mesh</td><td>valid pointer to <em>non-const</em> coarsest mesh </td></tr>
    <tr><td class="paramname">mesh_factory</td><td>factory object creating new meshes during refinement</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Stores shared pointer to coarsest mesh.</li>
<li>Sets <em>refinement edges</em> of all cells according to the longest-edge criterion.</li>
<li>Initializes <code>ChildInfo</code> data structures of all entities to indicate absence of children, since no refinement has been done yet.</li>
<li>Fills void <code><a class="el" href="structlf_1_1refinement_1_1_parent_info.html" title="Information about possible parent entities.">ParentInfo</a></code> data structure, since the mesh has not been created by refinement.</li>
<li>Unmarks all edges, see <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html#a693d5d31b5aaf0b9e077d890f3062022" title="Conduct local refinement of the mesh splitting all marked edges.">RefineMarked()</a>. </li>
</ul>

</div>
</div>
<a id="a10de191109487dbf85b47569f0436c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10de191109487dbf85b47569f0436c14">&#9670;&nbsp;</a></span>MeshHierarchy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lf::refinement::MeshHierarchy::MeshHierarchy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac210c02aec4ae49d35e3247fdd8a7621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac210c02aec4ae49d35e3247fdd8a7621">&#9670;&nbsp;</a></span>MeshHierarchy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lf::refinement::MeshHierarchy::MeshHierarchy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3dbdcde909f8c68b9fb1ed3851c3342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dbdcde909f8c68b9fb1ed3851c3342">&#9670;&nbsp;</a></span>~MeshHierarchy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual lf::refinement::MeshHierarchy::~MeshHierarchy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a334d3018f4bad589a6a81e52df16e178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334d3018f4bad589a6a81e52df16e178">&#9670;&nbsp;</a></span>CellChildInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html">CellChildInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::CellChildInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain refinement information for all. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html" title="Information about the refinement status of a cell.">CellChildInfo</a> record for every node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_cell_child_info.html" title="Information about the refinement status of a cell.">CellChildInfo</a> </dd></dl>

</div>
</div>
<a id="ab71cfa216aa13d280d814894811b09b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71cfa216aa13d280d814894811b09b2">&#9670;&nbsp;</a></span>Coarsen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::Coarsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em>Destroy</em> the mesh on the finest level unless it is the base mesh </p>
<dl class="section note"><dt>Note</dt><dd>the use of shared pointers prevents destruction if the finest mesh is still in use somewhere else in the code. </dd></dl>

</div>
</div>
<a id="a0fe86a285de7b155b4eabc7233cba4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe86a285de7b155b4eabc7233cba4a5">&#9670;&nbsp;</a></span>EdgeChildInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html">EdgeChildInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::EdgeChildInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain refinement information for all edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html" title="Information about the refinement status of an edge.">EdgeChildInfo</a> record for every node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_edge_child_info.html" title="Information about the refinement status of an edge.">EdgeChildInfo</a> </dd></dl>

</div>
</div>
<a id="acac0a1402387dd65921e3c1adc8752bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac0a1402387dd65921e3c1adc8752bc">&#9670;&nbsp;</a></span>GeometryInParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlf_1_1geometry_1_1_geometry.html">lf::geometry::Geometry</a>* lf::refinement::MeshHierarchy::GeometryInParent </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shape of child entity in parent's reference coordinates </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>level of the fine mesh in the mesh hierarchy </td></tr>
    <tr><td class="paramname">e</td><td>reference to entity object of the fine mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to geometry description of entity of fine mesh with respect to reference coordinate system of its parent entity.</dd></dl>
<p>We consider the shape of the reference entity of the parent entity of e as a triangulated domain, if the parent entity has a positive dimension, that is, if it is not a point. The entities of that triangulation correspond to the reference shapes of the child entities on the fine mesh. This method returns the shape of an entity of that triangulation.</p>
<p>Example: The case of a quadrilateral split into four child entities, corresponding to <code>rp_threeedge</code> as defined in <a class="el" href="namespacelf_1_1refinement.html#aad00cb5a8084400b931b01984d2cdc5d">lf::refinement::RefPat</a>, <a class="el" href="classlf_1_1refinement_1_1_hybrid2_d_refinement_pattern.html#a7848898a6646e900a09923d3600bc18e">lf::refinement::Hybrid2DRefinementPattern::ChildPolygons()</a>. The following image gives the local child numbers in pink. </p><div class="image">
<img src="rp_threeedge_unitsquare.png" alt="" width="500px"/>
</div>
<p> The geometries of the child entities are as follows:</p>
<ul>
<li>Child 0: quadrilateral with corners <p class="formulaDsp">
\[ \left[\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 1 &amp; 0.5 &amp; 0.5 \end{array}\right] \]
</p>
</li>
<li>Child 1: triangle with corners <p class="formulaDsp">
\[ \left[\begin{array}{ccc} 0 &amp; 0.5 &amp; 0 \\ 0 &amp; 0 &amp; 0.5 \end{array} \right] \]
</p>
</li>
<li>Child 2: triangle with corners <p class="formulaDsp">
\[ \left[\begin{array}{ccc} 1 &amp; 0.5 &amp; 1 \\ 0.5 &amp; 0 &amp; 0 \end{array} \right] \]
</p>
</li>
<li>Child 3: triangle with corners <p class="formulaDsp">
\[ \left[\begin{array}{ccc} 0.5 &amp; 1 &amp; 0 \\ 0 &amp; 0.5 &amp; 0.5 \end{array} \right] \]
</p>
</li>
</ul>
<p>One of the displayed matrices is returned if the entity <code>e</code> corresponds to that child of a quadrilateral. </p>

</div>
</div>
<a id="a94c5d43197587173c285f2689868bd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c5d43197587173c285f2689868bd9d">&#9670;&nbsp;</a></span>getMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a>&gt; lf::refinement::MeshHierarchy::getMesh </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the mesh on a particular level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>specifies level of interest, 0 stands for coarsest level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to mesh on specified level </dd></dl>

</div>
</div>
<a id="af6af114a5d79f8cf99ed0d501dd417c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6af114a5d79f8cf99ed0d501dd417c1">&#9670;&nbsp;</a></span>getMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a>&gt; lf::refinement::MeshHierarchy::getMesh </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the mesh on a particular level </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>specifies level of interest, 0 stands for coarsest level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to mesh on specified level </dd></dl>

</div>
</div>
<a id="a43f47c1d0b430311541771d26dceec21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f47c1d0b430311541771d26dceec21">&#9670;&nbsp;</a></span>getMeshes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;const <a class="el" href="classlf_1_1mesh_1_1_mesh.html">mesh::Mesh</a>&gt; &gt; lf::refinement::MeshHierarchy::getMeshes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides array of shared pointers to meshes contained in the hierarchy. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of shared pointers to <a class="el" href="namespacelf_1_1mesh.html" title="Defines a set of interface classes that define a mesh manager and provides mesh-related tools that bu...">lf::mesh</a>:Mesh objects </dd></dl>

</div>
</div>
<a id="aa4608cfc81660a615e4a23c1476b7a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4608cfc81660a615e4a23c1476b7a7d">&#9670;&nbsp;</a></span>MarkEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Marker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::MarkEdges </td>
          <td>(</td>
          <td class="paramtype">Marker &amp;&amp;&#160;</td>
          <td class="paramname"><em>marker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the edges of a mesh based on a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">marker</td><td>this should be functor of type <code>std::function&lt;bool(const Mesh &amp;,const Entity &amp;)&gt;</code> returning true if the passed edge is to be marked.</td></tr>
  </table>
  </dd>
</dl>
<p>The <em>marker</em> object also takes a reference to a mesh, because marking makes sense only for the finest level. The mesh on the finest level is provided to the marker object by the <code><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html" title="A hierarchy of nested 2D hybrid meshes created by refinement.">MeshHierarchy</a></code>.</p>
<p>Of course, marking will always affect the finest mesh in hierarchy. </p>

</div>
</div>
<a id="ac36a331c1ae18dc09cf8eb720feae67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36a331c1ae18dc09cf8eb720feae67a">&#9670;&nbsp;</a></span>NumLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type lf::refinement::MeshHierarchy::NumLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of meshes contained in the hierarchy, 1 for a single mesh </p>

</div>
</div>
<a id="abc774617bd6c1c960ffaee7026f68fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc774617bd6c1c960ffaee7026f68fe9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a>&amp; lf::refinement::MeshHierarchy::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb411a057bb85d8c585d4ff09edeee7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb411a057bb85d8c585d4ff09edeee7f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a>&amp; lf::refinement::MeshHierarchy::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlf_1_1refinement_1_1_mesh_hierarchy.html">MeshHierarchy</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a031ca0ccdbbb8a52174f1c4ff64cdb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031ca0ccdbbb8a52174f1c4ff64cdb41">&#9670;&nbsp;</a></span>ParentEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a>* lf::refinement::MeshHierarchy::ParentEntity </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the parent of an entity contained in a mesh of a refinement hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level &gt; 0 of the fine mesh </td></tr>
    <tr><td class="paramname">e</td><td>pointer to (potential) child entity, must be contained in mesh on the specified level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to parent entity</dd></dl>
<dl class="section note"><dt>Note</dt><dd>to be used in combination with @GeometryInParent() </dd></dl>

</div>
</div>
<a id="a546b2981a5c074c72e56c4592a5f253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546b2981a5c074c72e56c4592a5f253d">&#9670;&nbsp;</a></span>ParentInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_parent_info.html">ParentInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::ParentInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dim_t&#160;</td>
          <td class="paramname"><em>codim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch information about parents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level of interest </td></tr>
    <tr><td class="paramname">codim</td><td>co-dimension of entities to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_parent_info.html" title="Information about possible parent entities.">ParentInfo</a> record for every entity</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_parent_info.html" title="Information about possible parent entities.">ParentInfo</a> </dd></dl>

</div>
</div>
<a id="ac538ac9d7b9f1128a251ab17dbd125b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac538ac9d7b9f1128a251ab17dbd125b7">&#9670;&nbsp;</a></span>PointChildInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structlf_1_1refinement_1_1_point_child_info.html">PointChildInfo</a>&gt;&amp; lf::refinement::MeshHierarchy::PointChildInfos </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain refinement information for all points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level to be queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector for <a class="el" href="structlf_1_1refinement_1_1_point_child_info.html" title="Information about the refinement status of a point.">PointChildInfo</a> record for every node</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf_1_1refinement_1_1_point_child_info.html" title="Information about the refinement status of a point.">PointChildInfo</a> </dd></dl>

</div>
</div>
<a id="a6b24ba9cfaefc163844b21c7d023c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b24ba9cfaefc163844b21c7d023c8a2">&#9670;&nbsp;</a></span>PrintInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; lf::refinement::MeshHierarchy::PrintInfo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output of information about the mesh hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>output stream, can be <code>std::cout</code> or similar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream</dd></dl>
<p>The type of output is controlled by the <code>ctrl_</code> static control variable. If its second bit is set, the output function of the mesh class is used.</p>
<p>This is a rudimentary implementation and should be extended. </p>

</div>
</div>
<a id="a693d5d31b5aaf0b9e077d890f3062022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693d5d31b5aaf0b9e077d890f3062022">&#9670;&nbsp;</a></span>RefineMarked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::RefineMarked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conduct local refinement of the mesh splitting all marked edges. </p>
<p>This method creates a new mesh by selectively (locally) refining entities of the current finest mesh in the hierarchy. Refinement is controlled by the boolean vector edge_marked_ that indicates, which edges must be refined (= split) in the course of refinement.</p>
<h3>Algorithm</h3>
<ul>
<li>First all marked edges are labelled as "to be split".</li>
<li><p class="startli">REPEAT</p><ul>
<li>Set refinement pattern of all cells to accommodate edges to be split</li>
<li>Add "to be split" tag to edges according to local refinement pattern for cells</li>
</ul>
<p class="startli">UNTIL no <em>extra</em> edges had to be tagged as "to be split"</p>
</li>
</ul>
<p>For details please consult the comments in mesh_hierarchy.cc</p>
<p>This algorithm ends with a set of local refinement patterns for every entity that is compatible with a <em>conforming</em> finite element mesh, that is, hanging nodes are avoided. </p>

</div>
</div>
<a id="ae631d3d4b080210e7fe28b0cb18a6a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae631d3d4b080210e7fe28b0cb18a6a1b">&#9670;&nbsp;</a></span>RefinementEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;sub_idx_t&gt;&amp; lf::refinement::MeshHierarchy::RefinementEdges </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access refinement edge indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>refinement level of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of (local) sub-entity index of refinement edge for every cell </dd></dl>

</div>
</div>
<a id="a40f62ce5f838a648e584015fc712ab27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f62ce5f838a648e584015fc712ab27">&#9670;&nbsp;</a></span>RefineRegular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf::refinement::MeshHierarchy::RefineRegular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelf_1_1refinement.html#aad00cb5a8084400b931b01984d2cdc5d">RefPat</a>&#160;</td>
          <td class="paramname"><em>ref_pat</em> = <code>RefPat::rp_regular</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform regular or barycentric uniform refinement of the finest mesh in the hierarchy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_pat</td><td>selector for type of uniform refinement: default is rp_regular, rp_barycentric choses barycentric refinement.</td></tr>
  </table>
  </dd>
</dl>
<p>This method carries out uniform refinement of all cells of a mesh according to the <code>rp_regular</code> or <code>rp_barycentric</code> refinement patterns.</p>
<p>A new mesh is added to the bottom of the hierarchy by regularly refining the <em>finest mesh</em> in the hierarchy. Regular refinement means that every node is copied, every edge is split and every cell is subdivided into four or six smaller ones of the same shape.</p>
<p>Internally, this method flags all nodes as to be copied, all edges as to be split and all cells as to be refined according to the passed refinement pattern. Then it calls PerformRefinement(). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1f77d2d63daeeaedff7b10ecd6ef40f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f77d2d63daeeaedff7b10ecd6ef40f1">&#9670;&nbsp;</a></span>ctrl_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lf::refinement::MeshHierarchy::ctrl_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output control variable. </p>

</div>
</div>
<a id="a4de0f442177771c5f118ff6a63e11c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de0f442177771c5f118ff6a63e11c67">&#9670;&nbsp;</a></span>kout_meshinfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int lf::refinement::MeshHierarchy::kout_meshinfo = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af46f2b1255d3fcd15e30aac0ffbb98d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46f2b1255d3fcd15e30aac0ffbb98d9">&#9670;&nbsp;</a></span>output_ctrl_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int lf::refinement::MeshHierarchy::output_ctrl_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>diagnostics control variable </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/craffael/lehrfempp/lib/lf/refinement/<a class="el" href="mesh__hierarchy_8h_source.html">mesh_hierarchy.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclasslf_1_1refinement_1_1_mesh_hierarchy_html"><div class="ttname"><a href="classlf_1_1refinement_1_1_mesh_hierarchy.html">lf::refinement::MeshHierarchy</a></div><div class="ttdoc">A hierarchy of nested 2D hybrid meshes created by refinement.</div><div class="ttdef"><b>Definition:</b> mesh_hierarchy.h:115</div></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_entity_html"><div class="ttname"><a href="classlf_1_1mesh_1_1_entity.html">lf::mesh::Entity</a></div><div class="ttdoc">Representation of a topological entity in a cellular complex.</div><div class="ttdef"><b>Definition:</b> entity.h:34</div></div>
<div class="ttc" id="aclasslf_1_1mesh_1_1_mesh_html"><div class="ttname"><a href="classlf_1_1mesh_1_1_mesh.html">lf::mesh::Mesh</a></div><div class="ttdoc">Abstract interface for objects representing a single mesh.</div><div class="ttdef"><b>Definition:</b> mesh_interface.h:68</div></div>
<div class="ttc" id="anamespacelf_1_1mesh_1_1test__utils_html_aac2db44aee673bd5c8a74e8577f0d851"><div class="ttname"><a href="namespacelf_1_1mesh_1_1test__utils.html#aac2db44aee673bd5c8a74e8577f0d851">lf::mesh::test_utils::GenerateHybrid2DTestMesh</a></div><div class="ttdeci">std::shared_ptr&lt; lf::mesh::Mesh &gt; GenerateHybrid2DTestMesh(int selector=0, double scale=1.0)</div><div class="ttdoc">Generates a simple 2D hybrid test mesh.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
